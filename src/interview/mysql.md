## mysql
- 用户名当主键的不足（唯一标识和不可修改，没有业务含义）
- 联合索引abc，查询bc不会走索引吗（不会）
- 最左匹配原则（联合索引取最左边的，like "A%"会走索引）
- 索引失效的原理和场景（函数计算破坏索引的有序性）
- B+树结构，为什么不用红黑树（树更高，IO次数更高）
- mysql一页多少kb（16kb）

### 数据库问题的几个方面
1. 数据库设计基础
  - 掌握数据库设计中的基本范式，以及基础概念，例如表、视图、索引、外键、序列号生成器等，
  - 掌握数据库的数据类型的使用，清楚业务实体关系与数据库结构的映射。
2. 数据库隔离级别
   - 掌握 MySQL 四种事务隔离级别的基础知识，并进一步了解 MVCC、Locking 等机制对于处理的进阶问题的解决；
   - 还需要了解不同索引类型的使用，甚至是底层数据结构和算法等。 
3. SQL 优化
   - 掌握基础的 SQL 调优技巧，至少要了解基本思路是怎样的，
   - 例如 SQL 怎样写才能更好利用索引、知道如何分析 SQL 执行计划等。 
4. 数据库架构设计
   - 掌握针对高并发等特定场景中的解决方案，如读写分离、分库分表等。

### 索引的引申问题
- 数据库索引底层使用的是什么数据结构和算法呢？
- 为什么 MySQL InnoDB 选择 B+Tree 当默认的索引数据结构？
- 如何通过执行计划查看索引使用详情？
- 有哪些情况会导致索引失效？
- 平时有哪些常见的优化索引的方法？
### 掌握的知识点
- 理解 MySQL InnoDB 的索引原理；
  - 聚簇索引，非主键查询有时会回表
- 掌握 B+Tree 相比于其他索引数据结构（如 B-Tree、二叉树，以及 Hash 表）的优势；
  - 相对b树（非叶子节点也存储数据）
    - B+Tree 的单个节点的数据量更小，相同的磁盘 I/O 次数下，就能查询更多的节点
    - B+Tree 叶子节点采用的是双链表连接，适合范围查找，(B 树没有)
  - 二叉树索引结构
    - N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个
    - 在实际中，d值大于100，因此即使千万级数据，也只需要3~4层（层数对应IO次数）
    - 二叉树只有左右两个子节点，复杂度是O(logN)
  - Hash 表存储结构
    - 范围查询是 MySQL 中常见的场景，但是 Hash 表不适合做范围查询，它更适合做等值的查询，
- 掌握 MySQL 执行计划的方法；
- 掌握导致索引失效的常见情况；
- 掌握实际工作中常用的建立高效索引的技巧（如前缀索引、建立覆盖索引等）。


### 索引失效
解释：如果 MySQL 查询优化器预估走索引的代价比全表扫描的代价还要大，则不走对应的索引，直接全表扫描，如果走索引比全表扫描代价小，则使用索引。
- 索引列上做了计算、函数、类型转换操作，这些情况下索引失效是因为查询过程需要扫描整个索引并回表，代价高于直接全表扫描；
- like 匹配使用了前缀匹配符 ‘%abc’； 
- 字符串不加引号导致类型转换；

### 索引优化
- 前缀索引优化：用某个字段中，字符串的前几个字符建立索引
- 覆盖索引优化：query 的所有字段，在索引 B+tree 的叶子节点上都能找得到的那些索引，从辅助索引中查询得到记录，而不需要通过聚簇索引查询获得。
- 联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。
  - 越靠前的字段被用于索引过滤的概率越高
  - 实际开发工作中建立联合索引时，要把区分度大的字段排在前面

### 索引的问题
数据的写入延迟，引入额外的空间消耗；海量数据下，想要通过索引提升查询效率也是有限的


### 悲观锁和乐观锁
- 悲观锁：认为数据出现冲突的可能性很大
  - 一般利用 SELECT … FOR UPDATE 类似的语句，对数据加锁，避免其他事务意外修改数据
- 乐观锁：认为数据出现冲突的可能性不大
  - 利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，实现版本判断

### 怎么理解脏读、不可重复读和幻读？
- 脏读： 读到了未提交事务的数据
  - 脏读对应的隔离级别是“读未提交”，只有该隔离级别才会出现脏读。
  - 脏读的解决办法是升级事务隔离级别，比如“读已提交”。
- 不可重复读： 事务 A 先读取一条数据，然后执行逻辑的过程中，事务 B 更新了这条数据，事务 A 再读取时，发现数据不匹配，这个现象就是“不可重复读”。
  - 简单理解是两次读取的数据中间被修改，对应的隔离级别是“读未提交”或“读已提交”。 
  - 不可重复读的解决办法就是升级事务隔离级别，比如“可重复度”。
- 幻读： 在一个事务内，同一条查询语句在不同时间段执行，得到不同的结果集。
  - 要想解决幻读不能升级事务隔离级别到“可串行化”，那样数据库也失去了并发处理能力。 
  - 行锁解决不了幻读，因为即使锁住所有记录，还是阻止不了插入新数据。 
  - 解决幻读的办法是锁住记录之间的“间隙”，为此 MySQL InnoDB 引入了新的锁，叫间隙锁（Gap Lock），所以在面试中，你也要掌握间隙锁，以及间隙锁与行锁结合的 next-key lock 锁。

### 怎么理解死锁
#### 死锁是如何产生的（4个必要条件）
1. 互斥
   - 多个线程不能同时使用一个资源。比如线程 A 已经持有的资源，不能再同时被线程 B 持有。
   - 如果线程 B 请求获取线程 A 已经占有的资源，那线程 B 只能等待这个资源被线程 A 释放。
2. 持有并等待
   - 当线程 A 已经持有了资源 1，又提出申请资源 2，但是资源 2 已经被线程 C 占用，
   - 所以线程 A 就会处于等待状态，但它在等待资源 2 的同时并不会释放自己已经获取的资源 1。
3. 不可剥夺
   - 线程 A 获取到资源 1 之后，在自己使用完之前不能被其他线程（比如线程 B）抢占使用。
   - 如果线程 B 也想使用资源 1，只能在线程 A 使用完后，主动释放后再获取。
4. 循环等待
   - 发生死锁时，必然会存在一个线程，也就是资源的环形链。比如线程 A 已经获取了资源 1，但同时又请求获取资源 2。
   - 线程 B 已经获取了资源 2，但同时又请求获取资源 1，这就会形成一个线程和资源请求等待的环形图。
5. 死锁只有同时满足互斥、持有并等待、不可剥夺、循环等待时才会发生。

#### 如何避免死锁。
- 至少破坏其中一个条件（互斥必须满足，否则加锁没有意义，你可以从其他三个条件出发）
1. 持有并等待
   - 我们可以一次性申请所有的资源，这样就不存在等待了。
2. 不可剥夺
   - 占用部分资源的线程进一步申请其他资源时，如果申请不到，
   - 可以主动释放它占有的资源，这样不可剥夺这个条件就破坏掉了。
3. 循环等待
   - 可以靠按序申请资源来预防，也就是所谓的资源有序分配原则，让资源的申请和使用有线性顺序，
   - 申请的时候可以先申请资源序号小的，再申请资源序号大的，这样的线性化操作就自然就不存在循环了。

### 读多写少的场景如何优化
- 读写分离是提升 MySQL 并发的首选方案，因为当单台 MySQL 无法满足要求时，就只能用多个具有相同数据的 MySQL 实例组成的集群来承担大量的读写请求。
  - 写数据时只写主库，在读数据时只读从库（读通常比写多几个数量级）
- MySQL 集群如何实现主从复制？
  - 总的来讲，MySQL 的主从复制依赖于 binlog ，复制的过程就是将 binlog 中的数据从主库传输到从库上。
  - 这个过程一般是异步的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。
  - 主要步骤
    - 写入 Binlog：MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。
    - 同步 Binlog：从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。
    - 回放 Binlog：从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。
- 模式
  - 同步复制：事务线程要等待所有从库的复制成功响应。
  - 异步复制：事务线程完全不等待从库的复制成功响应。
  - 半同步复制：兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。
    - MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，
    - 比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。
- 共识机制：复制状态机（同 Raft 协议，在 Redis Cluster 中也用到了 backlog 来实现主从节点的数据复制，其方式和 MySQL一模一样。）
  - 目的是通过日志复制和回放的方式来实现集群中所有节点内的状态一致性。
  - 主要过程
    - 如果客户端将要执行的命令发送给集群中的一台服务器，那么这台服务器就会以日志的方式记录这条命令，
    - 然后将命令发送给集群内其他的服务，并记录在其他服务器的日志文件中，
    - 注意，只要保证各个服务器上的日志是相同的，并且各服务器都能以相同的顺序执行相同的命令的话，那么集群中的每个节点的执行结果也都会是一样的。
- 在系统设计上有哪些方案可以解决主从复制的延迟问题？
  - 使用数据冗余
    - 把需要在从库读取的数据直接发送给需求方（主库写入时）
  - 使用缓存解决
    - 写入主库时，在redis也写一份
    - 不过这种方式会带来缓存和数据库的一致性问题（多线程写redis）
  - 直接查询主库（慎用）
    - 主库写请求锁行，影响读请求的执行，最终对主库造成比较大的压力。
- 实现主库和从库的数据库访问
    - 一种简单的做法
      - 提前把所有数据源配置在工程中，每个数据源对应一个主库或者从库，
      - 然后改造代码，在代码逻辑中进行判断，将SQL语句发送给某一个指定的数据源来处理。
    - 优缺点
      - 方案简单易实现，但 SQL 路由规则侵入代码逻辑，在复杂的工程中不利于代码的维护。
    - 另一个做法
      - 独立部署的代理中间件，如 MyCat，这一类中间件部署在独立的服务器上，
      - 一般使用标准的 MySQL 通信协议，可以代理多个数据库。
    - 优缺点
      - 隔离底层数据库与上层应用的访问复杂度，比较适合有独立运维团队的公司选型；
      - 缺陷是所有的 SQL 语句都要跨两次网络传输，有一定的性能损耗，再就是运维中间件是一个专业且复杂的工作，需要一定的技术沉淀。

### 数据库写入请求量过大，导致系统出现性能与可用性问题（写多读少）
- A:对存储数据做分片，常见的方式就是对数据库做“分库分表”，在实现上有三种策略
  - 垂直拆分（列拆分）
    - 优缺点：把不同的业务数据进行隔离，更有助于架构上的扩展；不能解决某一个业务的数据大量膨胀的问题
  - 水平拆分（行拆分）
    - 拆分的规则就是哈希分片和范围分片
      - 范围分片
        - 按照某一个字段的区间来拆分，最好理解的就是按照时间字段分片，比如可以把一个月的数据放入一张表中
        - 缺点：容易导致数据分配不均
      - 比较
        - 常见的Range分片是按照字段类型，比如按照商品的所属品类进行分片。
        - 这样与 Hash 分片不同的是，Range 分片就可以加入对于业务的预估。（Hash分片比较机械，只是取模操作）
  - 垂直水平拆分
    - 综合垂直和水平拆分方式的一种混合方式，垂直拆分把不同类型的数据存储到不同库中，再结合水平拆分，使单表数据量保持在合理范围内，提升性能。
  - 热点数据问题
    - 垂直扩展：“增强单机硬件性能”是最快的方法
    - 分片元数据：分片的规则记录在一张表里面，每次执行查询的时候，先去表里查一下要找的数据在哪个分片中。
    - 高并发终极解决方案（水平扩展）
    - 可通过缓存提速（要保持高可用）
- 拆分后如何解决数据查询问题？
  - 聚合查询使用频繁时，可以将聚合查询的数据同步到 ES 中，
  - 将计数的数据单独存储在一张表里。
  - 如果是每日定时生成的统计类报表数据，也可以将数据同步到 HDFS 中，然后用一些大数据技术来生成报表。

### 追问
  - 什么场景该分库？什么场景该分表？
    - 何时分表
      - 当数据量过大造成事务执行缓慢时，就要考虑分表（主要指写，读的问题可以通过主从分离解决）
    - 何时分库
      - 为了应对高并发，一个数据库实例撑不住，即单库的性能无法满足高并发的要求，就把并发请求分散到多个实例中去
  - 复杂的业务如何选择分片策略？
  - 如何解决分片后的数据查询问题？
  - 技术拓展：NewSQL 
    - 新一代的分布式数据库，不但具备分布式存储系统的高性能、高可用，弹性扩容等能力，
    - 还兼容传统关系型数据库的 SQL 标准
    - 还提供了和传统关系型数据库不相上下的事务保证，是具备了支撑未来交易类业务能力的。
#### 实例：订单表用什么字段分表？分表后按时间段查询，怎么办？
    
#### 实例：1000w的db数据分页怎么处理

### 出现了use filesort怎么解决
- Using filesort 的含义很简单，就是使用了排序操作，出现这个选项的常见情况就是 Where 条件和 order by 子句作用在了不同的列上
- 解决：添加联合索引，联合where和order by子句的两个列即可

### log有哪些（七种）？有什么用
- 重做日志（redo log）：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。
- 回滚日志（undo log）：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性
- 二进制日志（binlog）：用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步；用于数据库的基于时间点的还原；事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。
- 错误日志（error log）：错误日志记录着mysqld启动和停止,以及服务器在运行过程中发生的错误的相关信息。
- 慢查询日志（slow query log）：慢日志记录执行时间过长和没有使用索引的查询语句（可选项），报错select、update、delete以及insert语句，慢日志只会记录执行成功的语句。
- 一般查询日志（general log）：记录了服务器接收到的每一个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误
- 中继日志（relay log）： 中继日志也是二进制日志，用来给slave 库恢复


### b+树比b树的优势
- 块内节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。
- 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。
- 所有的叶子节点形成了一个有序链表，更加便于范围查找。

### 索引失效
1. 违反最左前缀法则，如果索引有多列，要遵守最左前缀法则，即查询从索引的最左前列开始并且不跳过索引中的列
2. 在索引列上做任何操作，如计算、函数、（自动or手动）类型转换等操作，会导致索引失效从而全表扫描
3. 索引范围条件右边的列，here name = 'zhangsan' and age > 20 and pos = 'cxy'，pos不会走索引
4. 尽量使用覆盖索引
5. 使用不等于（!=、<>），会导致全表扫描
6. like以通配符开头（'%abc'）
7. 字符串不加单引号索引失效
8. or连接
9. order by、group by



### 隔离级别，有何不同
1. 读未提交（READ UNCOMMITTED）
    - 任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交。会脏读
2. 读提交 （READ COMMITTED）
    - 读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。但是不能解决重复读问题（两次读结果不一致）和幻读
3. 可重复读 （REPEATABLE READ）：事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。
    - 通过MVCC解决重复读问题
4. 串行化 （SERIALIZABLE）：将事务的执行变为顺序执行

### 快照读和当前读
1. 快照读：读取的是记录数据的可见版本（可能是过期的数据），不用加锁，当执行select的时候，innodb默认会执行快照读，相当于就是给你目前的状态找了一张照片，以后执行select 的时候就会返回当前照片里面的数据，当其他事务提交了也对你不造成影响，和你没关系，这就实现了可重复读了，那这个照片是什么时候生成的呢？不是开启事务的时候，是当你第一次执行select的时候，也就是说，当A开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有B添加的那条数据......之后无论再有其他事务commit都没有关系，因为照片已经生成了，而且不会再生成了，以后都会参考这张照片。
2. 当前读：读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录。
    - select * from table where ? lock in share mode; 共享锁
    - select * from table where ? for update; 排它锁
    - insert；
    - update；
    - delete；
3. InnoDb是如何实现快照读的？

### 幻读及使用MVCC及间隙锁解决幻读
- 幻读：同一个事务里面连续执行两次同样的sql语句，可能导致不同结果的问题，第二次sql语句可能会返回之前不存在的行。
- MVCC也会幻读
    - a事务先select，b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意操作），
    - a事务再select出来的结果在MVCC下还和第一次select一样，
    - 接着a事务不加条件地update，这个update会作用在所有行上（包括b事务新加的），
    - a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了.
    - 上面这样，事务2提交之后，事务1再次执行update，因为这个是当前读，他会读取最新的数据，包括别的事务已经提交的，所以就会导致此时前后读取的数据不一致，出现幻读。
- 事务1在update后，对该数据加锁（行锁 + 间隙锁），事务B无法插入新的数据，这样事务A在update前后数据保持一致，避免了幻读
- 结论
    - 快照读的幻读是用MVCC解决的，当前的读的幻读是用间隙锁解决的。在rr级别下，mvcc完全解决了重复读，但并不能真正的完全避免幻读，只是在部分场景下利用历史数据规避了幻读
    - 对于快照读，mysql使用mvcc利用历史数据部分避免了幻读（在某些场景看上去规避了幻读）
    - 要完全避免，需要手动加锁将快照读调整为当前读（mysql不会自动加锁），然后mysql使用next-key完全避免了幻读，比如rr下，锁1（0，2，3，4），另一个线程的insert 3即被阻塞，在rc下，另一个线程仍然可以大摇大摆的插入，如本线程再次查询比如count，则会不一致



### 为何用B+树作为索引
1. 很适合磁盘存储，能够充分利用局部性原理，磁盘预读；
2. 很低的树高度，能够存储大量数据；
3. 索引本身占用的内存很小；
4. 能够很好的支持单点查询，范围查询，有序性查询；

### 为何索引不用hash
1. Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
2. Hash 索引无法被用来避免数据的排序操作。
    - 由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；
3. Hash 索引不能利用部分索引键查询。
    - 对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
4. Hash 索引在任何时候都不能避免表扫描。（hash一样数据不一定一样）
5. Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

### MyISAM与InnoDB的索引差异
#### MyISAM 索引
MyISAM的索引与行记录是分开存储的，叫做非聚集索引（UnClustered Index）。其主键索引与普通索引没有本质差异
    - 有连续聚集的区域单独存储行记录
    - 主键索引的叶子节点，存储主键，与对应行记录的指针
    - 普通索引的叶子结点，存储索引列，与对应行记录的指针
    - 可以没有主键

#### InnoDB索引
1. InnoDB的主键索引与行记录是存储在一起的，故叫做聚集索引（Clustered Index）
    - 没有单独区域存储行记录
    - 主键索引的叶子节点，存储主键，与对应行记录（而不是指针）
    - InnoDB的PK查询是非常快的。

2. InnoDB的表必须要有聚集索引：
    - 如果表定义了PK，则PK就是聚集索引；
    - 如果表没有定义PK，则第一个非空unique列是聚集索引；
    - 否则，InnoDB会创建一个隐藏的row-id作为聚集索引；
    
    
### 为什么mysql默认是innodb
功能对比
1.功能对比
    - InnoDB支持ACID的事务4个特性，而MyISAM不支持；
    - InnoDB支持4种事务隔离级别，默认是可重复读repeatable read，MyISAM不支持；
    - InnoDB 支持crash安全恢复，MyISAM不支持；InnoDB支持外键，MyISAM不支持；
    - InnoDB支持行级别的锁粒度，MyISAM不支持，只支持表级别的锁粒度；
    - InnoDB支持MVCC，MyISAM不支持。
    - InnoDB特性上，InnoDB表最大可以64TB，支持聚簇索引、支持压缩数据存储，支持数据加密，支持查询/索引/数据高速缓存，支持自适应hash索引、空间索引，支持热备份和恢复等。
2. 性能对比
    - 读写混合模式下，随着CPU核数的增加，InnoDB的读写能力呈线性增长，在这个测试用例里，最高可达近9000的TPS，但MyISAM因为读写不能并发，它的处理能力跟核数没关系，呈一条水平线，TPS低于500。
    - 只读模式下，随着CPU核数的增加，InnoDB的读写能力呈线性增长，最高可达近14000的TPS，但MyISAM的处理能力不到3000。


### 记录锁（行锁，Record Locks）、间隙锁（Gap Locks）和临键锁（Next-Key Lock）区别
1. 记录锁：实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁
2. 间隙锁：基于非唯一索引，锁定一段范围内的索引记录。间隙锁基于Next-Key Locking 算法，使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。
    - SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE; 所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。
3. 临键锁：可以理解为一种特殊的间隙锁，通过临建锁可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。

### innodb四大特性
1. 插入缓冲 （Insert Buffer/Change Buffer）：前者主要提升插入性能，后者对insert、delete和update和purge都有效。优化的是非唯一二级索引
    - 每一次的插入不是写到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则直接插入；若不在，则先放到Insert Buffer 中，再按照一定的频率进行合并操作，再写回disk。这样通常能将多个插入合并到一个操作中，目的还是减少了随机IO带来性能损耗
2. 双写机制（Double Write）：首先会将（memcpy函数）Page刷到InnoDB tablespace的一个区域中，我们称该区域为Double write Buffer，在双写到共享表空间和数据文件中。其中共享表空间（2MB）为顺序写，作为备份，磁盘为随机写，若失败则从共享表空间中恢复即可
3. 自适应哈希索引（Adaptive Hash Index，AHI）：InnoDB存储引擎会监控对表上辅助索引页（用索引键的前缀）的查询。如果观察到建立hash索引可以提升性能，就会在缓冲池建立hash索引，称之为自适应哈希索引
4. 预读 （Read Ahead）：异步将磁盘的页读取到buffer pool中，预料这些页会马上被读取到。预读请求的所有页集中在一个范围内。
    - Linear read-ahead：线性预读技术预测在buffer pool中被访问到的数据它临近的页也会很快被访问到
    - Random read-ahead: 随机预读通过buffer pool中存中的来预测哪些页可能很快会被访问，而不考虑这些页的读取顺序
    
### Mysql以页最小存储单位存到磁盘上，从磁盘发展的角度，页可以怎么优化
- 一个思路
  - Mysql页大小为16kb，磁盘的扇区大小为512bytes（传统机械硬盘）
  - 随着磁盘发展，一次原子写入块大小比如为4kb
  - 可以将页设置与磁盘的一次性原子写入块大小相等
  - 这样Mysql进行脏页落盘就不需要double write了，对应的double write区也可以去掉了
- 另一个思路（核心是减少磁盘IO）
  - 使用SSD硬盘，其读写更快，耐用性更高
  - 使用大页（Large Pages）：可以减少页表的大小，进而减少CPU的缓存失效率，提高IO效率
- 使用压缩算法

### 索引覆盖
如果一个索引覆盖（包含）了所有需要查询的字段的值，这个索引就是覆盖索引。因为索引中已经包含了要查询的字段的值，因此查询的时候直接返回索引中的字段值就可以了，不需要再到表中查询，避免了对主键索引的二次查询，也就提高了查询的效率。

### Mysql是从内存读还是从磁盘读？
- 缓存和buffer pool（8.0弃用了缓存）
- 再从顺序IO和page
- 最后要避免磁盘的多次访问
- 答：先从缓存，没有则从内存中，再没有从磁盘读入内存buffer pool

### order by的实现原理
1. 利用有序索引获取有序数据；
2. 文件排序。
- 在使用explain分析查询的时候，利用有序索引获取有序数据显示Using index。如果MySQL在排序的时候没有使用到索引那么就会输出using filesort，即使用文件排序。

### sort_buffer默认容量大小，超过容量怎么办？（了解sort_buffer写入文件的机制）
8M，最大16M。写入临时文件的三个时机
- 每写入一条数据写入临时文件
- 每秒线程调用写入
- 缓冲区使用超过一半时写入

### 索引下推（MySQL5.6添加）
二级索引树中做一次过滤，减少回表次数


### 关系型和非关系型数据库区别
1. 关系型数据库：采用了关系模型来组织数据的数据库。简单来说，关系模式就是二维表格模型。
    - 优点：
        - 容易理解
        - 使用方便，通用的sql语句使得操作关系型数据库非常方便。
        - 易于维护，数据库的ACID属性，大大降低了数据冗余和数据不一致的概率。
    - 缺点：
        - 海量数据的读写效率，硬盘I/o是一个很大的挑战。
        - 高扩展性和可用性
2. 非关系型数据库：NoSQL提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构，可以减少一些时间和空间的开销。
    - 优点：
        - 易扩展
        - 大数据量，高性能
        - 灵活的数据模型：NoSQL无须事先为要存储的数据建立字段，随时可以存储自定义的数据格式。
        - 高可用
    - 缺点：但是由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。
3. 对比
    - 存储格式：关系型采用数据库表，Nosql采用k-v形式
    - 事务：前者支持，后者不支持
    - 预定义结构 VS 动态结构
    - 前者扩展性不好，后者扩展性好，易于水平扩展
    - 关系型是结构化查询语言，NoSql是采用更简单而且精确的数据访问方式；

### 自增ID和业务相关的全局唯一ID的特点
- 什么是雪花id算法
- 主键和唯一约束是两件事
  - 主键自增主要是为了聚簇索引，自增时只需要在顺序写，业务id存在随机写的情况，同时也可能存在B+树的分裂和调整
  - 唯一约束可以用来分库分表（主键和分表关系不大）

#### 1000w条记录的表，索引高度是几
- 3，主键ID是long类型，占用8字节
- InnoDb占用6字节，假设一行数据大小1k
- 2层最多存储的数据为16KB/14*16=18720
- 3层最多保存的数据量为16KB/14*16KB/14 *16=21902400，因此约2000w
- 其中16是一页存储的记录条数（页大小默认16K，除以一行数据1k）

#### 一个表有几亿数据，怎么遍历？
- 从聚簇索引说起，分治+并行
  - 先找到主键的几个分页位置，然后并行查询，最后再merge
- 深度分页的问题？？？
- 再建议分库分表

#### Mysql的深分页问题
- 比如 limit 10 offset 1000w的问题？原理 & 解决

    
### 执行计划
- ALL（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）。

#### 为什么不把Mysql备份放到从库中去？

### LSM树是干嘛的？（简单了解即可）

#### 哪些情况会引起索引失效？

#### 外键的优缺点

### 慢查询怎么定位？怎么解决ƒ
