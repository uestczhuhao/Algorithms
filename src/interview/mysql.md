## mysql
- 用户名当主键的不足（唯一标识和不可修改，没有业务含义）
- 联合索引abc，查询bc不会走索引吗（不会）
- 最左匹配原则（联合索引取最左边的）
- 索引失效的原理和场景（函数计算破坏索引的有序性）
- B+树结构，为什么不用红黑树（树更高，IO次数更高）
- mysql一页多少kb（16kb）
- 


### 出现了use filesort怎么解决
- Using filesort 的含义很简单，就是使用了排序操作，出现这个选项的常见情况就是 Where 条件和 order by 子句作用在了不同的列上
- 解决：添加联合索引，联合where和order by子句的两个列即可

### log有哪些（七种）？有什么用
- 重做日志（redo log）：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。
- 回滚日志（undo log）：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性
- 二进制日志（binlog）：用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步；用于数据库的基于时间点的还原；事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。
- 错误日志（errorlog）：错误日志记录着mysqld启动和停止,以及服务器在运行过程中发生的错误的相关信息。
- 慢查询日志（slow query log）：慢日志记录执行时间过长和没有使用索引的查询语句（可选项），报错select、update、delete以及insert语句，慢日志只会记录执行成功的语句。
- 一般查询日志（general log）：记录了服务器接收到的每一个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误
- 中继日志（relay log）： 中继日志也是二进制日志，用来给slave 库恢复


### b+树比b树的优势
- 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。
- 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。
- 所有的叶子节点形成了一个有序链表，更加便于查找。

### 索引失效
1. 违反最左前缀法则，如果索引有多列，要遵守最左前缀法则，即查询从索引的最左前列开始并且不跳过索引中的列
2. 在索引列上做任何操作，如计算、函数、（自动or手动）类型转换等操作，会导致索引失效从而全表扫描
3. 索引范围条件右边的列，here name = 'zhangsan' and age > 20 and pos = 'cxy'，pos不会走索引
4. 尽量使用覆盖索引
5. 使用不等于（!=、<>），会导致全表扫描
6. like以通配符开头（'%abc'）
7. 字符串不加单引号索引失效
8. or连接
9. order by、group by



### 隔离级别，有何不同
1. 读未提交（READ UNCOMMITTED）
    - 任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交。会脏读
2. 读提交 （READ COMMITTED）
    - 读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。但是不能解决重复读问题（两次读结果不一致）和幻读
3. 可重复读 （REPEATABLE READ）：事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。
    - 通过MVCC解决重复读问题
4. 串行化 （SERIALIZABLE）：将事务的执行变为顺序执行

### 快照读和当前读
1. 快照读：读取的是记录数据的可见版本（可能是过期的数据），不用加锁，当执行select的时候，innodb默认会执行快照读，相当于就是给你目前的状态找了一张照片，以后执行select 的时候就会返回当前照片里面的数据，当其他事务提交了也对你不造成影响，和你没关系，这就实现了可重复读了，那这个照片是什么时候生成的呢？不是开启事务的时候，是当你第一次执行select的时候，也就是说，当A开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有B添加的那条数据......之后无论再有其他事务commit都没有关系，因为照片已经生成了，而且不会再生成了，以后都会参考这张照片。

2. 当前读：读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录。
    - select * from table where ? lock in share mode; 共享锁
    - select * from table where ? for update; 排它锁
    - insert；
    - update；
    - delete；

### 幻读及使用MVCC及间隙锁解决幻读
- 幻读：同一个事务里面连续执行两次同样的sql语句，可能导致不同结果的问题，第二次sql语句可能会返回之前不存在的行。
- MVCC也会幻读
    - a事务先select，b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意操作），
    - a事务再select出来的结果在MVCC下还和第一次select一样，
    - 接着a事务不加条件地update，这个update会作用在所有行上（包括b事务新加的），
    - a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了.
    - 上面这样，事务2提交之后，事务1再次执行update，因为这个是当前读，他会读取最新的数据，包括别的事务已经提交的，所以就会导致此时前后读取的数据不一致，出现幻读。
- 事务1在update后，对该数据加锁（行锁 + 间隙锁），事务B无法插入新的数据，这样事务A在update前后数据保持一致，避免了幻读
- 结论
    - 快照读的幻读是用MVCC解决的，当前的读的幻读是用间隙锁解决的。在rr级别下，mvcc完全解决了重复读，但并不能真正的完全避免幻读，只是在部分场景下利用历史数据规避了幻读
    - 对于快照读，mysql使用mvcc利用历史数据部分避免了幻读（在某些场景看上去规避了幻读）
    - 要完全避免，需要手动加锁将快照读调整为当前读（mysql不会自动加锁），然后mysql使用next-key完全避免了幻读，比如rr下，锁1（0，2，3，4），另一个线程的insert 3即被阻塞，在rc下，另一个线程仍然可以大摇大摆的插入，如本线程再次查询比如count，则会不一致



### 为何用B+树作为索引
1. 很适合磁盘存储，能够充分利用局部性原理，磁盘预读；
2. 很低的树高度，能够存储大量数据；
3. 索引本身占用的内存很小；
4. 能够很好的支持单点查询，范围查询，有序性查询；

### 为何索引不用hash
1. Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
2. Hash 索引无法被用来避免数据的排序操作。
    - 由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；
3. Hash 索引不能利用部分索引键查询。
- 对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
4. Hash 索引在任何时候都不能避免表扫描。（hash一样数据不一定一样）
5. Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

### MyISAM与InnoDB的索引差异
#### MyISAM 索引
MyISAM的索引与行记录是分开存储的，叫做非聚集索引（UnClustered Index）。其主键索引与普通索引没有本质差异
    - 有连续聚集的区域单独存储行记录
    - 主键索引的叶子节点，存储主键，与对应行记录的指针
    - 普通索引的叶子结点，存储索引列，与对应行记录的指针
    - 可以没有主键

#### InnoDB索引
1. InnoDB的主键索引与行记录是存储在一起的，故叫做聚集索引（Clustered Index）
    - 没有单独区域存储行记录
    - 主键索引的叶子节点，存储主键，与对应行记录（而不是指针）
    - InnoDB的PK查询是非常快的。

2. InnoDB的表必须要有聚集索引：
    - 如果表定义了PK，则PK就是聚集索引；
    - 如果表没有定义PK，则第一个非空unique列是聚集索引；
    - 否则，InnoDB会创建一个隐藏的row-id作为聚集索引；
    
    
### 为什么mysql默认是innodb
功能对比
1.功能对比
    - InnoDB支持ACID的事务4个特性，而MyISAM不支持；
    - InnoDB支持4种事务隔离级别，默认是可重复读repeatable read，MyISAM不支持；
    - InnoDB 支持crash安全恢复，MyISAM不支持；InnoDB支持外键，MyISAM不支持；
    - InnoDB支持行级别的锁粒度，MyISAM不支持，只支持表级别的锁粒度；
    - InnoDB支持MVCC，MyISAM不支持。
    - InnoDB特性上，InnoDB表最大可以64TB，支持聚簇索引、支持压缩数据存储，支持数据加密，支持查询/索引/数据高速缓存，支持自适应hash索引、空间索引，支持热备份和恢复等。
2. 性能对比
    - 读写混合模式下，随着CPU核数的增加，InnoDB的读写能力呈线性增长，在这个测试用例里，最高可达近9000的TPS，但MyISAM因为读写不能并发，它的处理能力跟核数没关系，呈一条水平线，TPS低于500。

    - 只读模式下，随着CPU核数的增加，InnoDB的读写能力呈线性增长，最高可达近14000的TPS，但MyISAM的处理能力不到3000。


### 记录锁（行锁，Record Locks）、间隙锁（Gap Locks）和临键锁（Next-Key Lock）区别
1. 记录锁：实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁
2. 间隙锁：基于非唯一索引，锁定一段范围内的索引记录。间隙锁基于Next-Key Locking 算法，使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。
    - SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE; 所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。
3. 临键锁：可以理解为一种特殊的间隙锁，通过临建锁可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。

### innodb四大特性
1. 插入缓冲 （Insert Buffer/Change Buffer）：前者主要提升插入性能，后者对insert、delete和update和purge都有效。优化的是非唯一二级索引
    - 每一次的插入不是写到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则直接插入；若不在，则先放到Insert Buffer 中，再按照一定的频率进行合并操作，再写回disk。这样通常能将多个插入合并到一个操作中，目的还是减少了随机IO带来性能损耗
2. 双写机制（Double Write）：首先会将（memcpy函数）Page刷到InnoDB tablespace的一个区域中，我们称该区域为Double write Buffer，在双写到共享表空间和数据文件中。其中共享表空间（2MB）为顺序写，作为备份，磁盘为随机写，若失败则从共享表空间中恢复即可
3. 自适应哈希索引（Adaptive Hash Index，AHI）：InnoDB存储引擎会监控对表上辅助索引页（用索引键的前缀）的查询。如果观察到建立hash索引可以提升性能，就会在缓冲池建立hash索引，称之为自适应哈希索引
4. 预读 （Read Ahead）：异步将磁盘的页读取到buffer pool中，预料这些页会马上被读取到。预读请求的所有页集中在一个范围内。
    - Linear read-ahead：线性预读技术预测在buffer pool中被访问到的数据它临近的页也会很快被访问到
    - Random read-ahead: 随机预读通过buffer pool中存中的来预测哪些页可能很快会被访问，而不考虑这些页的读取顺序


### 索引覆盖
如果一个索引覆盖（包含）了所有需要查询的字段的值，这个索引就是覆盖索引。因为索引中已经包含了要查询的字段的值，因此查询的时候直接返回索引中的字段值就可以了，不需要再到表中查询，避免了对主键索引的二次查询，也就提高了查询的效率。


### order by的实现原理
1. 利用有序索引获取有序数据；
2. 文件排序。
- 在使用explain分析查询的时候，利用有序索引获取有序数据显示Using index。如果MySQL在排序的时候没有使用到索引那么就会输出using filesort，即使用文件排序。

### sort_buffer默认容量大小，超过容量怎么办？（了解sort_buffer写入文件的机制）
8M，最大16M。写入临时文件的三个时机
- 每写入一条数据写入临时文件
- 每秒线程调用写入
- 缓冲区使用超过一半时写入